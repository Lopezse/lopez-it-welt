{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 3, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 67, "column": 0}, "map": {"version":3,"sources":["file:///D:/Projekte/lopez-it-welt/src/app/api/admin/time-tracking/sessions/route.ts"],"sourcesContent":["import { promises as fs } from \"fs\";\nimport { NextRequest, NextResponse } from \"next/server\";\nimport path from \"path\";\n\ninterface TimeSession {\n  id: number;\n  user_id: number;\n  module: string;\n  start_time: string;\n  end_time?: string;\n  duration_minutes?: number;\n  taetigkeit: string;\n  status: \"active\" | \"completed\" | \"interrupted\";\n  problem?: string;\n  ausloeser?: string;\n  category: string;\n  priority: string;\n  created_at: string;\n  updated_at: string;\n}\n\n// Datei-Pfad f√ºr Sessions\nconst SESSIONS_FILE = path.join(process.cwd(), \"data\", \"time-sessions.json\");\n\n// Sessions laden\nasync function loadSessions(): Promise<TimeSession[]> {\n  try {\n    const data = await fs.readFile(SESSIONS_FILE, \"utf-8\");\n    return JSON.parse(data);\n  } catch (error) {\n    // Datei existiert nicht oder ist leer\n    return [];\n  }\n}\n\n// Sessions speichern\nasync function saveSessions(sessions: TimeSession[]): Promise<void> {\n  try {\n    // Verzeichnis erstellen falls nicht vorhanden\n    const dir = path.dirname(SESSIONS_FILE);\n    await fs.mkdir(dir, { recursive: true });\n\n    await fs.writeFile(SESSIONS_FILE, JSON.stringify(sessions, null, 2));\n  } catch (error) {\n    // Fehler beim Speichern der Sessions: ${error}\n  }\n}\n\n// Korrekte aktuelle Zeit (Deutschland mit Sommerzeit)\nfunction getCurrentTime(): string {\n  const now = new Date();\n  // Automatische Sommerzeit-Erkennung\n  return now.toISOString();\n}\n\n// Alle offenen Sessions beenden\nasync function closeAllOpenSessions(): Promise<void> {\n  try {\n    const sessions = await loadSessions();\n    const now = new Date().toISOString();\n    let hasChanges = false;\n\n    for (let i = 0; i < sessions.length; i++) {\n      const session = sessions[i];\n      if (session.status === \"active\" && !session.end_time) {\n        const startDate = new Date(session.start_time);\n        const endDate = new Date(now);\n        const durationMinutes = Math.round((endDate.getTime() - startDate.getTime()) / (1000 * 60));\n\n        sessions[i] = {\n          ...session,\n          end_time: now,\n          duration_minutes: Math.max(0, durationMinutes),\n          status: \"completed\",\n          updated_at: now,\n        };\n        hasChanges = true;\n        // Offene Session automatisch beendet: ${session.module} (${durationMinutes} Min)\n      }\n    }\n\n    if (hasChanges) {\n      await saveSessions(sessions);\n    }\n  } catch (error) {\n    // Fehler beim Beenden offener Sessions: ${error}\n  }\n}\n\nexport async function GET() {\n  try {\n    const sessions = await loadSessions();\n    return NextResponse.json(sessions);\n  } catch (error) {\n    // Fehler beim Abrufen der Sessions: ${error}\n    return NextResponse.json({ error: \"Fehler beim Abrufen der Sessions\" }, { status: 500 });\n  }\n}\n\nexport async function POST(request: NextRequest) {\n  try {\n    // KEINE automatische Beendigung mehr - echte Zeiterfassung!\n    // await closeAllOpenSessions(); // ENTFERNT\n\n    const body = await request.json();\n    const {\n      user_id,\n      module,\n      taetigkeit,\n      ausloeser,\n      problem,\n      category = \"development\",\n      priority = \"medium\",\n      project_id,\n      task_id,\n    } = body;\n\n    // Validierung: Pflichtfelder\n    if (!user_id) {\n      return NextResponse.json({ error: \"user_id ist ein Pflichtfeld\" }, { status: 400 });\n    }\n    if (!project_id) {\n      return NextResponse.json({ error: \"project_id ist ein Pflichtfeld\" }, { status: 400 });\n    }\n    if (!task_id) {\n      return NextResponse.json({ error: \"task_id ist ein Pflichtfeld\" }, { status: 400 });\n    }\n    if (!taetigkeit || taetigkeit.trim().length < 8) {\n      return NextResponse.json(\n        { error: \"taetigkeit ist ein Pflichtfeld (mindestens 8 Zeichen)\" },\n        { status: 400 },\n      );\n    }\n    if (taetigkeit.length > 180) {\n      return NextResponse.json(\n        { error: \"taetigkeit darf maximal 180 Zeichen lang sein\" },\n        { status: 400 },\n      );\n    }\n\n    // Validierung: Keine technischen Namen\n    const technicalPatterns = [\n      /\\.tsx?$/i,\n      /\\.jsx?$/i,\n      /component/i,\n      /page-component/i,\n      /route/i,\n      /index\\./i,\n    ];\n    const hasTechnicalPattern = technicalPatterns.some((pattern) => pattern.test(taetigkeit));\n    if (hasTechnicalPattern) {\n      return NextResponse.json(\n        {\n          error:\n            \"taetigkeit darf keine technischen Namen enthalten (z.B. .tsx, Component, Route). Verwende verst√§ndliche Beschreibungen.\",\n        },\n        { status: 400 },\n      );\n    }\n\n    const sessions = await loadSessions();\n    \n    // üîí WICHTIG: Pr√ºfe ob bereits eine aktive Session f√ºr diesen Benutzer existiert\n    const activeSession = sessions.find(\n      (s) => s.user_id === user_id && s.status === \"active\" && !s.end_time\n    );\n\n    if (activeSession) {\n      // Es existiert bereits eine aktive Session - diese zur√ºckgeben\n      return NextResponse.json(\n        { \n          message: \"Aktive Session existiert bereits\",\n          session: activeSession,\n          id: activeSession.id\n        },\n        { status: 200 }\n      );\n    }\n\n    // Keine aktive Session vorhanden - neue Session erstellen\n    const now = getCurrentTime();\n    const maxId = sessions.length > 0 ? Math.max(...sessions.map((s) => s.id)) : 0;\n\n    const session: TimeSession = {\n      id: maxId + 1,\n      user_id,\n      module: module || taetigkeit.substring(0, 50), // Fallback f√ºr module\n      taetigkeit,\n      ausloeser,\n      problem,\n      category,\n      priority,\n      project_id,\n      task_id,\n      start_time: now,\n      status: \"active\",\n      created_at: now,\n      updated_at: now,\n    };\n\n    sessions.push(session);\n    await saveSessions(sessions);\n\n    // Neue Session erstellt: ${session.module} - ${session.taetigkeit} (${now})\n    return NextResponse.json(session, { status: 201 });\n  } catch (error) {\n    // Fehler beim Erstellen der Session: ${error}\n    return NextResponse.json({ error: \"Fehler beim Erstellen der Session\" }, { status: 500 });\n  }\n}\n\nexport async function PUT(request: NextRequest) {\n  try {\n    const body = await request.json();\n    const { id, ...updateData } = body;\n\n    const sessions = await loadSessions();\n    const sessionIndex = sessions.findIndex((s) => s.id === id);\n\n    if (sessionIndex === -1) {\n      return NextResponse.json({ error: \"Session nicht gefunden\" }, { status: 404 });\n    }\n\n    const now = getCurrentTime();\n    const updatedSessionData = {\n      ...sessions[sessionIndex],\n      ...updateData,\n      updated_at: now,\n    };\n\n    sessions[sessionIndex] = updatedSessionData;\n    await saveSessions(sessions);\n\n    return NextResponse.json(updatedSessionData);\n  } catch (error) {\n    // Fehler beim Aktualisieren der Session: ${error}\n    return NextResponse.json({ error: \"Fehler beim Aktualisieren der Session\" }, { status: 500 });\n  }\n}\n"],"names":[],"mappings":"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","debugId":null}}]
}